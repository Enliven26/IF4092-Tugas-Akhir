[{"diff": "diff --git a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\nindex e6e2a4cd8..1c6fcda23 100644\n--- a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n+++ b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n@@ -12,0 +13 @@ import org.springframework.http.CacheControl\n+import org.springframework.scheduling.annotation.EnableScheduling\n@@ -23,0 +25 @@ import javax.servlet.MultipartConfigElement\n+@EnableScheduling\ndiff --git a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\nindex fa5c1f80c..a86be1125 100644\n--- a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n+++ b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n@@ -69 +69 @@ class ImageUploadService(\n-    logger.info(\"Clearing images\")\n+    logger.debug(\"Clearing images\")\n", "source_code": "src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (Before)\n\nsrc/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (After)\n\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (Before)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.info(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (After)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.debug(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}", "high_level_context": "FEATURE-TOLGEE-30  \n**Title: User Authentication**  \n**Description:** This feature allows users to securely log in to the application using their credentials. It ensures that only authorized users can access the platform's services and data.  \n**Requirements:**  \n1. **Login Mechanism:** Users should be able to enter their username and password to access their accounts. This mechanism must validate the credentials against stored records securely.  \n2. **Password Recovery:** The system should provide an option for users to recover their passwords through email verification. This ensures that users can regain access to their accounts if they forget their passwords.  \n3. **Session Management:** The application must maintain user sessions effectively, allowing users to stay logged in for a specified duration and providing an option to log out.  \n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nFEATURE-TOLGEE-12  \n**Title: Image Upload Functionality**  \n**Description:** This feature allows users to upload images to the platform for various purposes, including profile pictures and content creation. It is essential for enhancing user engagement and content richness.  \n**Requirements:**  \n1. **Upload Interface:** Users should have access to a simple and intuitive interface to upload images. The interface must support drag-and-drop functionality as well as traditional file selection methods.  \n2. **File Validation:** The system must validate the uploaded images to ensure they meet specified criteria, such as file size and type. This prevents unsupported files from being processed, ensuring a smooth user experience.  \n3. **Image Storage:** Once uploaded, images must be stored securely with appropriate naming conventions to prevent conflicts and ensure easy retrieval for future use.  \n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nFEATURE-TOLGEE-26  \n**Title: User Profile Management**  \n**Description:** This feature enables users to manage their profiles, including personal information and preferences. It is crucial for providing a personalized experience on the platform.  \n**Requirements:**  \n1. **Profile Editing:** Users should be able to edit their profile information, including name, email, and bio. Changes made should be saved and reflected in real time.  \n2. **Privacy Settings:** The application must allow users to set privacy preferences for their profiles, including who can view their information and content. This enhances user control over their personal data.  \n3. **Profile Picture Update:** Users should have the ability to change their profile pictures easily. The system must support uploading a new image and replacing the existing one without complications.  \n\n--- RETRIEVED DOCUMENT SPLIT END ---", "commit_message": "fix: Uploaded images are not deleted periodically TG-353"}, {"diff": "diff --git a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\nindex 348bea7e5..9dc65f1b3 100644\n--- a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n+++ b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n@@ -59 +59 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-                .subscribe({ show ->\n+                .subscribe { show ->\n@@ -65 +65 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-                })\n+                }\n@@ -70 +70 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-                .subscribe({ name_text_view.text = it })\n+                .subscribe { name_text_view.text = it }\n@@ -96,4 +95,0 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-        privacy_row.setOnClickListener {\n-            startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java))\n-        }\n-\n", "source_code": "app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (Before)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe({ show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } })\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe({ name_text_view.text = it })\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        privacy_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}\napp/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (After)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } }\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { name_text_view.text = it }\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}", "high_level_context": "USERSTORY-Settings-28\n\n1. **User Profile Display**  \n   Users should be able to see their profile information on the settings screen. This includes displaying the user's avatar, username, and version number of the application. The avatar should be fetched from a provided URL and displayed in a circular format to enhance the visual appeal of the profile section.\n\n2. **Logout Functionality**  \n   The application must provide a logout option within the settings. When the user clicks on the logout button, a confirmation prompt should appear to ensure that the user intends to log out. This is to prevent accidental logouts and enhance user experience.\n\n3. **Debug Visibility**  \n   In debug mode, an option to edit the profile should be visible for testing purposes. This allows developers and testers to verify the edit functionality without needing to navigate through other parts of the application.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nUSERSTORY-Settings-10\n\n1. **Navigation to Account Settings**  \n   Users should have the ability to navigate to their account settings from the main settings screen. A dedicated row labeled \"Account\" should be present, allowing users to easily transition to the account management section.\n\n2. **Help Access**  \n   There should be a help section accessible from the settings menu. This feature allows users to seek assistance regarding the application functionalities, enhancing user support and satisfaction.\n\n3. **Newsletter Subscription Management**  \n   Users must be able to manage their newsletter subscriptions within the settings. A designated row for newsletters should be included, enabling users to subscribe or unsubscribe from updates effectively.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nUSERSTORY-Settings-25\n\n1. **Notification Preferences**  \n   The settings screen must include an option for users to manage their notification preferences. Users should be able to toggle various notification settings to tailor their experience according to their preferences.\n\n2. **Privacy Settings**  \n   A section for privacy settings should be available, allowing users to manage their privacy options. This includes enabling or disabling data sharing and adjusting visibility settings related to their account.\n\n3. **Rate the App Feature**  \n   Users should have the ability to rate the application directly from the settings menu. A dedicated row should be provided for this action, facilitating user feedback and encouraging positive engagement with the application.\n\n--- RETRIEVED DOCUMENT SPLIT END ---", "commit_message": "Removing privacy from root Settings menu (#456)"}, {"diff": "diff --git a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\nindex 470821ebe..03de4e4bb 100644\n--- a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n+++ b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n@@ -30,0 +31 @@ import com.breadwallet.tools.manager.BRSharedPrefs\n+import com.breadwallet.tools.util.EventUtils\n@@ -58,0 +60,2 @@ object MessagesRepository {\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\ndiff --git a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\nindex 66f470850..9c5294ff5 100644\n--- a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n+++ b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n@@ -51,0 +52,2 @@ class InAppNotificationActivity : BRActivity() {\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n@@ -72,0 +75,4 @@ class InAppNotificationActivity : BRActivity() {\n+            val notificationId = viewModel.notification.id\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId,\n+                            EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n@@ -91,0 +98,2 @@ class InAppNotificationActivity : BRActivity() {\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n", "source_code": "app/src/main/java/com/breadwallet/repository/MessagesRepository.kt (Before)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/repository/MessagesRepository.kt (After)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (Before)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (After)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            val notificationId = viewModel.notification.id\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId, EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n    }\n}", "high_level_context": "**EPIC-BREAD-29**  \n**Title: In-App Notification Retrieval**  \n1. **Description**  \n   The application must be able to retrieve in-app notifications for the user. This feature aims to enhance user engagement by providing timely updates and alerts directly within the app interface.\n\n2. **User Interaction**  \n   Users should see new notifications upon opening the app, ensuring they are informed of relevant messages without needing to check external sources. The notifications will be displayed prominently to capture the user's attention.\n\n3. **Notification Handling**  \n   Once a notification is displayed, the system must track which notifications have been read. This ensures that users do not receive duplicate notifications for the same message, thereby improving the overall user experience.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n**EPIC-BREAD-13**  \n**Title: In-App Notification Display**  \n1. **Description**  \n   The application must provide a dedicated interface for displaying in-app notifications. This interface should be user-friendly and visually appealing, allowing users to interact with the notifications effectively.\n\n2. **User Actions**  \n   Users should be able to dismiss notifications or take action on them (e.g., clicking on a button within the notification). The interface must include clear options for users to engage with the content of the notification.\n\n3. **Notification Details**  \n   Each notification should present essential information, including a title, message body, and an optional action button. This will allow users to understand the purpose of the notification at a glance and decide on the next steps.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n**EPIC-BREAD-22**  \n**Title: Event Tracking for Notifications**  \n1. **Description**  \n   The application must track user interactions with in-app notifications to gather insights on user behavior and notification effectiveness. This data is crucial for improving the app's engagement strategies.\n\n2. **Event Logging**  \n   Every significant user interaction with notifications, such as viewing, dismissing, or clicking on action buttons, must be logged. This will provide valuable analytics for understanding how users interact with notifications.\n\n3. **Analytics Integration**  \n   The logged events should be integrated with an analytics platform to visualize user engagement data. This integration will help in making informed decisions about future notification strategies and improvements.\n\n--- RETRIEVED DOCUMENT SPLIT END ---", "commit_message": "DROID-1355: Add analytics for in-app messages."}]