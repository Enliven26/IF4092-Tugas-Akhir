[
    {
        "diff": "diff --git a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\nindex e6e2a4cd8..1c6fcda23 100644\n--- a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n+++ b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n@@ -10,6 +10,7 @@ import org.springframework.boot.web.servlet.MultipartConfigFactory\n import org.springframework.context.annotation.Bean\n import org.springframework.context.annotation.Configuration\n import org.springframework.http.CacheControl\n+import org.springframework.scheduling.annotation.EnableScheduling\n import org.springframework.util.unit.DataSize\n import org.springframework.web.client.RestTemplate\n import org.springframework.web.servlet.config.annotation.CorsRegistry\n@@ -21,6 +22,7 @@ import java.util.concurrent.TimeUnit\n import javax.servlet.MultipartConfigElement\n \n @Configuration\n+@EnableScheduling\n class WebConfiguration(\n   private val tolgeeProperties: TolgeeProperties\n ) : WebMvcConfigurer {\ndiff --git a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\nindex fa5c1f80c..a86be1125 100644\n--- a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n+++ b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n@@ -66,7 +66,7 @@ class ImageUploadService(\n   @Transactional\n   @Scheduled(fixedRate = 60000)\n   fun cleanOldImages() {\n-    logger.info(\"Clearing images\")\n+    logger.debug(\"Clearing images\")\n     val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n     uploadedImageRepository.findAllOlder(Date.from(time)).let { images ->\n       images.forEach { delete(it) }\n",
        "source_code": "src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (Before)\n@Configuration class WebConfiguration(private val tolgeeProperties: TolgeeProperties) : WebMvcConfigurer{\n\n}\nsrc/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (After)\n@Configuration @EnableScheduling class WebConfiguration(private val tolgeeProperties: TolgeeProperties) : WebMvcConfigurer{\n\n}\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (Before)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.info(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (After)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.debug(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}",
        "high_level_context": "User Interface Design\n\nThe application should provide an intuitive and user-friendly interface that allows users to easily navigate through its functionalities. The design should incorporate modern UI principles, ensuring that all elements are accessible and clearly labeled for optimal user experience.\n\n1. Layout and Navigation\n   - The main dashboard should present a clear overview of the application's features, with easy access to different sections.\n   - Navigation menus should be consistent across all pages, allowing users to switch between functionalities without confusion.\n\n2. Visual Elements\n   - Use of visually appealing graphics and icons to enhance engagement and understanding of the application's purpose.\n   - Color schemes should be consistent and supportive of the branding while ensuring readability and accessibility.\n\nIntegration and Functionality\n\nThe application must seamlessly integrate with various external services and provide robust functionality to meet user needs. It should support efficient data management and ensure the performance of core features.\n\n1. Data Handling\n   - The system should allow users to upload and manage images effectively, including features for sorting, filtering, and deleting as needed.\n   - Regular maintenance processes should be implemented to clean up outdated or unnecessary data, enhancing overall system performance.\n\n2. Scheduling and Automation\n   - The application should include scheduling capabilities for routine tasks, ensuring that operations such as data cleanup occur automatically without user intervention.\n\nPerformance and Reliability\n\nThe application must prioritize performance and reliability to provide users with a consistent experience. This includes handling high volumes of data and maintaining operational stability under various conditions.\n\n1. System Efficiency\n   - The application should be optimized for fast loading times and responsive interactions, even when processing large datasets.\n   - Regular performance assessments should be conducted to identify potential bottlenecks and areas for improvement.\n\n2. Error Handling and Logging\n   - Implement comprehensive error handling to manage unexpected issues gracefully, providing users with informative feedback.\n   - Logging mechanisms should be in place to monitor system activities and assist in troubleshooting, ensuring issues can be diagnosed and resolved promptly.",
        "commit_message": "fix: Uploaded images are not deleted periodically TG-353"
    },
    {
        "diff": "diff --git a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\nindex 348bea7e5..9dc65f1b3 100644\n--- a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n+++ b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n@@ -56,18 +56,18 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n         this.viewModel.outputs.showConfirmLogoutPrompt()\n                 .compose(bindToLifecycle())\n                 .observeOn(AndroidSchedulers.mainThread())\n-                .subscribe({ show ->\n+                .subscribe { show ->\n                     if (show) {\n                         lazyLogoutConfirmationDialog().show()\n                     } else {\n                         lazyLogoutConfirmationDialog().dismiss()\n                     }\n-                })\n+                }\n \n         this.viewModel.outputs.userNameTextViewText()\n                 .compose(bindToLifecycle())\n                 .compose(Transformers.observeForUI())\n-                .subscribe({ name_text_view.text = it })\n+                .subscribe { name_text_view.text = it }\n \n         account_row.setOnClickListener {\n             startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java))\n@@ -93,10 +93,6 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n             startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java))\n         }\n \n-        privacy_row.setOnClickListener {\n-            startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java))\n-        }\n-\n         rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n     }\n \n",
        "source_code": "app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (Before)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe({ show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } })\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe({ name_text_view.text = it })\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        privacy_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}\napp/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (After)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } }\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { name_text_view.text = it }\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}",
        "high_level_context": "User Interface\n\nOverview\nThe application provides a user-friendly interface for managing user settings, ensuring that users can easily navigate through various options.\n\nProfile Management\n1. Avatar Display\n   Users can view their profile picture in the settings screen, which is dynamically loaded from a specified URL.\n   \n2. Username Display\n   The application will display the current user's name, allowing for easy identification.\n\nSettings Navigation\n1. Account Settings\n   Users can access their account details through the account settings option.\n\n2. Edit Profile\n   An option is available for users to edit their profile information, which enhances personalization.\n\nUser Interaction\n\nOverview\nThe application includes several interactive elements that enhance user engagement and streamline navigation.\n\nLogout Functionality\n1. Logout Prompt\n   Users will receive a confirmation prompt when they attempt to log out, ensuring that accidental logouts are minimized.\n\n2. Logout Action\n   Upon confirmation, the application will execute the logout process, redirecting users as necessary.\n\nNavigation Options\n1. Help Section\n   Users can access help-related content to assist with any inquiries or issues.\n\n2. Notification Preferences\n   An option is provided for users to manage their notification settings, allowing for a tailored user experience.\n\nVersion Information\n\nOverview\nThe application displays critical version information to keep users informed about the current build.\n\nVersion Display\n1. Version Number\n   The current version number of the application is shown prominently, providing transparency regarding updates and changes.\n\n2. Debug Visibility\n   In debug mode, additional options may be visible to facilitate testing and development processes.",
        "commit_message": "Removing privacy from root Settings menu (#456)"
    },
    {
        "diff": "diff --git a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\nindex 470821ebe..03de4e4bb 100644\n--- a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n+++ b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n@@ -28,6 +28,7 @@ import android.content.Context\n import android.util.Log\n import com.breadwallet.model.InAppMessage\n import com.breadwallet.tools.manager.BRSharedPrefs\n+import com.breadwallet.tools.util.EventUtils\n import com.platform.network.InAppMessagesClient\n \n /**\n@@ -56,6 +57,8 @@ object MessagesRepository {\n         // for notifications.\n         val inAppMessage = inAppMessages[0]\n         Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\n         return inAppMessage\n     }\n \ndiff --git a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\nindex 66f470850..9c5294ff5 100644\n--- a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n+++ b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n@@ -49,6 +49,8 @@ class InAppNotificationActivity : BRActivity() {\n         private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n \n         fun start(context: Context, notification: InAppMessage) {\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n             val intent = Intent(context, InAppNotificationActivity::class.java).apply {\n                 putExtra(EXT_NOTIFICATION, notification)\n             }\n@@ -70,6 +72,10 @@ class InAppNotificationActivity : BRActivity() {\n         notification_btn.setOnClickListener {\n             viewModel.markAsRead()\n             val actionUrl = viewModel.notification.actionButtonUrl\n+            val notificationId = viewModel.notification.id\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId,\n+                            EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n             if (!actionUrl.isNullOrEmpty()) {\n                 if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                     AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n@@ -89,6 +95,8 @@ class InAppNotificationActivity : BRActivity() {\n     override fun onBackPressed() {\n         super.onBackPressed()\n         viewModel.markAsRead()\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n     }\n \n }\n\\ No newline at end of file\n",
        "source_code": "app/src/main/java/com/breadwallet/repository/MessagesRepository.kt (Before)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/repository/MessagesRepository.kt (After)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (Before)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (After)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            val notificationId = viewModel.notification.id\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId, EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n    }\n}",
        "high_level_context": "In-App Notification Management\n\nOverview\nIn-app notifications are an essential feature of the application, providing users with timely updates and information directly within the app interface. This functionality enhances user engagement and ensures that important messages are communicated effectively.\n\n1. In-App Notification Retrieval\n   The system retrieves new in-app notifications that have not yet been read by the user. It checks for available notifications and filters out those that the user has already acknowledged. If new notifications exist, the first one is selected for display.\n\nUser Interaction with Notifications\n\nOverview\nUsers can interact with in-app notifications through various actions that enhance their experience and allow them to respond to the messages presented.\n\n1. Notification Display\n   When an in-app notification is triggered, the application presents the message to the user with relevant details such as the title, body, and any associated images. Users can view the notification and take further actions based on its content.\n\n2. Action Handling\n   Users have the option to perform actions related to the notification, including accessing external links. When a user clicks on the action button, the app determines if the link is a deep link and processes it accordingly. If it is a standard URL, the app opens it in a web browser.\n\nEvent Tracking and Analytics\n\nOverview\nTo understand user engagement and notification effectiveness, the system tracks various events related to in-app notifications. This data helps improve future notification strategies and enhances the overall user experience.\n\n1. Event Logging\n   Key events are logged when notifications are displayed, interacted with, or dismissed. This includes tracking when a notification appears, when the action button is clicked, and when the notification is dismissed. Each event captures relevant attributes for better analysis.\n\n2. Data Utilization\n   The collected event data is utilized to analyze user behavior and refine notification strategies. Insights derived from this data inform decisions on notification timing, content, and frequency, ultimately leading to a more tailored user experience.",
        "commit_message": "DROID-1355: Add analytics for in-app messages."
    }
]