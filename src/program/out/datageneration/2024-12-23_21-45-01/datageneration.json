[{"diff": "diff --git a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\nindex e6e2a4cd8..1c6fcda23 100644\n--- a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n+++ b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n@@ -12,0 +13 @@ import org.springframework.http.CacheControl\n+import org.springframework.scheduling.annotation.EnableScheduling\n@@ -23,0 +25 @@ import javax.servlet.MultipartConfigElement\n+@EnableScheduling\ndiff --git a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\nindex fa5c1f80c..a86be1125 100644\n--- a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n+++ b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n@@ -69 +69 @@ class ImageUploadService(\n-    logger.info(\"Clearing images\")\n+    logger.debug(\"Clearing images\")\n", "source_code": "src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (Before)\n\nsrc/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (After)\n\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (Before)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.info(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (After)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.debug(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}", "high_level_context": "USER-ImageUploader-5  \n**5. Image Upload Functionality**  \nThis requirement outlines the ability for users to upload images to the platform seamlessly.\n\n- **5.1 User Interface for Uploading Images**  \n  The application must provide an intuitive user interface where users can select and upload images. The UI should include drag-and-drop functionality as well as a traditional file selection dialog.\n\n- **5.2 Supported Image Formats**  \n  The system must support multiple image formats including JPEG, PNG, and GIF. Users should be notified if they attempt to upload unsupported formats.\n\n- **5.3 Upload Progress Indicator**  \n  While images are being uploaded, a progress bar should be displayed to inform users about the status of their upload. This enhances user experience by providing feedback on the process.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nUSER-ImageManagement-6  \n**6. Image Management Features**  \nThis requirement details features related to managing uploaded images within the application.\n\n- **6.1 Image Deletion**  \n  Users must have the ability to delete images they have uploaded. A confirmation prompt should appear to prevent accidental deletions.\n\n- **6.2 Image Gallery**  \n  The application should display a gallery view of all uploaded images, allowing users to browse, view, and select images for further actions.\n\n- **6.3 Metadata Tagging**  \n  Users should be able to add tags to their images for better organization and retrieval. The tagging system must support multiple tags per image.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nUSER-ImageCleanup-20  \n**20. Automated Image Cleanup**  \nThis requirement specifies the automatic cleanup of old images to optimize storage usage.\n\n- **20.1 Scheduled Cleanup Process**  \n  The application should implement a scheduled process that automatically deletes images older than two hours from the upload time. This helps in managing storage efficiently.\n\n- **20.2 Logging and Notifications**  \n  The cleanup process must log activities and notify administrators of the number of images deleted during each cleanup cycle. This ensures transparency and allows for monitoring storage management.\n\n- **20.3 User Notification of Cleanup**  \n  Users should receive notifications if their images are deleted during the automated cleanup process, providing clarity about the state of their uploads.\n\n--- RETRIEVED DOCUMENT SPLIT END ---", "commit_message": "fix: Uploaded images are not deleted periodically TG-353"}, {"diff": "diff --git a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\nindex 348bea7e5..9dc65f1b3 100644\n--- a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n+++ b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n@@ -59 +59 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-                .subscribe({ show ->\n+                .subscribe { show ->\n@@ -65 +65 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-                })\n+                }\n@@ -70 +70 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-                .subscribe({ name_text_view.text = it })\n+                .subscribe { name_text_view.text = it }\n@@ -96,4 +95,0 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n-        privacy_row.setOnClickListener {\n-            startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java))\n-        }\n-\n", "source_code": "app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (Before)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe({ show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } })\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe({ name_text_view.text = it })\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        privacy_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}\napp/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (After)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } }\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { name_text_view.text = it }\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}", "high_level_context": "DELIVERABLE-Settings-6  \n**User Requirement: Profile Management**  \nThis section outlines the requirements for managing user profiles within the application. Users should have the ability to view and edit their profile information seamlessly.\n\n1. **Profile Picture Display**  \n   Users should see their current profile picture displayed prominently on the settings page. The application must retrieve the user's avatar image from the server and present it using an appropriate transformation to ensure a circular appearance.\n\n2. **Username Visibility**  \n   The username of the user must be displayed clearly. If the user has not set a username, a placeholder should be shown indicating that they can edit this information.\n\n3. **Edit Profile Access**  \n   There should be an option for users to edit their profile. This will lead to a separate activity where users can change their username and update their profile picture.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nDELIVERABLE-Settings-26  \n**User Requirement: Logout Functionality**  \nThis section describes the requirements for the logout process within the application. Users must have a clear and secure way to log out of their account.\n\n1. **Logout Button**  \n   A logout button must be available on the settings page, allowing users to initiate the logout process easily.\n\n2. **Confirmation Prompt**  \n   Before logging out, the application must present a confirmation dialog to ensure that the user intends to log out. This dialog should be clear and provide options to confirm or cancel the logout action.\n\n3. **Post-Logout Behavior**  \n   Once the user confirms the logout action, they should be redirected to the login screen. Their session data must be cleared to protect their account information.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nDELIVERABLE-Settings-23  \n**User Requirement: Notifications Settings**  \nThis section outlines the requirements for managing notification preferences within the application. Users should be able to customize their notification settings to enhance their experience.\n\n1. **Notification Preferences Access**  \n   Users should have a dedicated section in the settings where they can access their notification preferences. This section must be easily navigable.\n\n2. **Toggle Notifications**  \n   Users must be able to enable or disable notifications for various activities within the application, such as project updates, messages, and promotional content.\n\n3. **Preview Notification Types**  \n   The application must provide a brief description of each type of notification, allowing users to make informed decisions about which notifications they wish to receive.\n\n--- RETRIEVED DOCUMENT SPLIT END ---", "commit_message": "Removing privacy from root Settings menu (#456)"}, {"diff": "diff --git a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\nindex 470821ebe..03de4e4bb 100644\n--- a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n+++ b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n@@ -30,0 +31 @@ import com.breadwallet.tools.manager.BRSharedPrefs\n+import com.breadwallet.tools.util.EventUtils\n@@ -58,0 +60,2 @@ object MessagesRepository {\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\ndiff --git a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\nindex 66f470850..9c5294ff5 100644\n--- a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n+++ b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n@@ -51,0 +52,2 @@ class InAppNotificationActivity : BRActivity() {\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n@@ -72,0 +75,4 @@ class InAppNotificationActivity : BRActivity() {\n+            val notificationId = viewModel.notification.id\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId,\n+                            EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n@@ -91,0 +98,2 @@ class InAppNotificationActivity : BRActivity() {\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n", "source_code": "app/src/main/java/com/breadwallet/repository/MessagesRepository.kt (Before)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/repository/MessagesRepository.kt (After)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (Before)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (After)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            val notificationId = viewModel.notification.id\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId, EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n    }\n}", "high_level_context": "**OBJECTIVE-BREADWALLET-25**  \n**Requirement Title:** In-App Notification Retrieval\n\n**Description:**  \nThe application must have the capability to retrieve in-app notifications for users. This feature is essential to keep users informed about important updates or messages without requiring them to leave the application.\n\n**Subsections:**\n\n1. **Notification Fetching Process:**  \n   The system should check for new in-app notifications upon user interaction or at predefined intervals. It should only fetch notifications that have not been read by the user to ensure a fresh and relevant user experience.\n\n2. **User Notification Tracking:**  \n   The application must maintain a record of read notifications using persistent storage. This ensures that once a notification has been viewed, it will not be presented again, thereby reducing clutter and enhancing user focus.\n\n3. **Logging and Analytics:**  \n   The application should log the retrieval of notifications for analytical purposes. This data can help in understanding user engagement and improving future notifications.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n**OBJECTIVE-BREADWALLET-13**  \n**Requirement Title:** In-App Notification Display\n\n**Description:**  \nThe application must provide a user-friendly interface to display in-app notifications when they are received. This interface should be intuitive and facilitate user interaction with the notifications.\n\n**Subsections:**\n\n1. **Notification User Interface:**  \n   The notifications should be displayed in a dedicated activity that presents the notification title, body, and any associated action buttons. The design should follow the application's existing aesthetic to maintain consistency.\n\n2. **User Interaction with Notifications:**  \n   Users should be able to interact with notifications through action buttons, which may lead to external links or other parts of the application. The action taken should be logged for tracking user engagement.\n\n3. **Dismissal and Read Tracking:**  \n   Users can dismiss notifications by navigating away from the notification activity. The application should mark notifications as read upon dismissal to prevent re-presentation of the same notifications.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n**OBJECTIVE-BREADWALLET-15**  \n**Requirement Title:** In-App Notification Analytics\n\n**Description:**  \nThe application must collect analytics related to in-app notifications to evaluate their performance and user engagement. This information will be crucial for improving notification strategies.\n\n**Subsections:**\n\n1. **Event Logging:**  \n   Each time a notification is displayed or interacted with, the application should log an event with relevant metadata, such as notification ID and user actions taken. This will provide insights into how users are engaging with notifications.\n\n2. **User Engagement Metrics:**  \n   The application should track key metrics, including the number of notifications sent, opened, and dismissed. Analyzing these metrics will help in refining notification content and timing.\n\n3. **Reporting Tools:**  \n   The application should integrate reporting tools that allow stakeholders to visualize and analyze notification performance over time, assisting in data-driven decision-making for future updates.\n\n--- RETRIEVED DOCUMENT SPLIT END ---", "commit_message": "DROID-1355: Add analytics for in-app messages."}]