[
    {
        "diff": "diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CopyCommands.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CopyCommands.java\nindex c4e42c94b93..e2fad7560e3 100644\n--- a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CopyCommands.java\n+++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CopyCommands.java\n@@ -53,24 +53,29 @@ public static void registerCommands(CommandFactory factory) {\n   /** merge multiple files together */\n   public static class Merge extends FsCommand {\n     public static final String NAME = \"getmerge\";    \n-    public static final String USAGE = \"[-nl] <src> <localdst>\";\n+    public static final String USAGE = \"[-nl] [-skip-empty-file] \"\n+        + \"<src> <localdst>\";\n     public static final String DESCRIPTION =\n-      \"Get all the files in the directories that \" +\n-      \"match the source file pattern and merge and sort them to only \" +\n-      \"one file on local fs. <src> is kept.\\n\" +\n-      \"-nl: Add a newline character at the end of each file.\";\n+        \"Get all the files in the directories that \"\n+        + \"match the source file pattern and merge and sort them to only \"\n+        + \"one file on local fs. <src> is kept.\\n\"\n+        + \"-nl: Add a newline character at the end of each file.\\n\"\n+        + \"-skip-empty-file: Do not add new line character for empty file.\";\n \n     protected PathData dst = null;\n     protected String delimiter = null;\n+    private boolean skipEmptyFileDelimiter;\n     protected List<PathData> srcs = null;\n \n     @Override\n     protected void processOptions(LinkedList<String> args) throws IOException {\n       try {\n-        CommandFormat cf = new CommandFormat(2, Integer.MAX_VALUE, \"nl\");\n+        CommandFormat cf = new CommandFormat(2, Integer.MAX_VALUE, \"nl\",\n+            \"skip-empty-file\");\n         cf.parse(args);\n \n         delimiter = cf.getOpt(\"nl\") ? \"\\n\" : null;\n+        skipEmptyFileDelimiter = cf.getOpt(\"skip-empty-file\");\n \n         dst = new PathData(new URI(args.removeLast()), getConf());\n         if (dst.exists && dst.stat.isDirectory()) {\n@@ -92,21 +97,26 @@ protected void processArguments(LinkedList<PathData> items)\n       FSDataOutputStream out = dst.fs.create(dst.path);\n       try {\n         for (PathData src : srcs) {\n-          FSDataInputStream in = src.fs.open(src.path);\n-          try {\n-            IOUtils.copyBytes(in, out, getConf(), false);\n-            if (delimiter != null) {\n-              out.write(delimiter.getBytes(\"UTF-8\"));\n+          if (src.stat.getLen() != 0) {\n+            try (FSDataInputStream in = src.fs.open(src.path)) {\n+              IOUtils.copyBytes(in, out, getConf(), false);\n+              writeDelimiter(out);\n             }\n-          } finally {\n-            in.close();\n+          } else if (!skipEmptyFileDelimiter) {\n+            writeDelimiter(out);\n           }\n         }\n       } finally {\n         out.close();\n-      }      \n+      }\n     }\n- \n+\n+    private void writeDelimiter(FSDataOutputStream out) throws IOException {\n+      if (delimiter != null) {\n+        out.write(delimiter.getBytes(\"UTF-8\"));\n+      }\n+    }\n+\n     @Override\n     protected void processNonexistentPath(PathData item) throws IOException {\n       exitCode = 1; // flag that a path is bad\n",
        "source_code": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CopyCommands.java (Before)\nclass CopyCommands {\n/**\n * merge multiple files together\n */\npublic static class Merge extends FsCommand {\n\n    public static final String NAME = \"getmerge\";\n\n    public static final String USAGE = \"[-nl] <src> <localdst>\";\n\n    public static final String DESCRIPTION = \"Get all the files in the directories that \" + \"match the source file pattern and merge and sort them to only \" + \"one file on local fs. <src> is kept.\\n\" + \"-nl: Add a newline character at the end of each file.\";\n\n    protected PathData dst = null;\n\n    protected String delimiter = null;\n\n    protected List<PathData> srcs = null;\n\n    @Override\n    protected void processOptions(LinkedList<String> args) throws IOException {\n        try {\n            CommandFormat cf = new CommandFormat(2, Integer.MAX_VALUE, \"nl\");\n            cf.parse(args);\n            delimiter = cf.getOpt(\"nl\") ? \"\\n\" : null;\n            dst = new PathData(new URI(args.removeLast()), getConf());\n            if (dst.exists && dst.stat.isDirectory()) {\n                throw new PathIsDirectoryException(dst.toString());\n            }\n            srcs = new LinkedList<PathData>();\n        } catch (URISyntaxException e) {\n            throw new IOException(\"unexpected URISyntaxException\", e);\n        }\n    }\n\n    @Override\n    protected void processArguments(LinkedList<PathData> items) throws IOException {\n        super.processArguments(items);\n        if (exitCode != 0) {\n            // check for error collecting paths\n            return;\n        }\n        FSDataOutputStream out = dst.fs.create(dst.path);\n        try {\n            for (PathData src : srcs) {\n                FSDataInputStream in = src.fs.open(src.path);\n                try {\n                    IOUtils.copyBytes(in, out, getConf(), false);\n                    if (delimiter != null) {\n                        out.write(delimiter.getBytes(\"UTF-8\"));\n                    }\n                } finally {\n                    in.close();\n                }\n            }\n        } finally {\n            out.close();\n        }\n    }\n\n    @Override\n    protected void processNonexistentPath(PathData item) throws IOException {\n        // flag that a path is bad\n        exitCode = 1;\n        super.processNonexistentPath(item);\n    }\n\n    // this command is handled a bit differently than others.  the paths\n    // are batched up instead of actually being processed.  this avoids\n    // unnecessarily streaming into the merge file and then encountering\n    // a path error that should abort the merge\n    @Override\n    protected void processPath(PathData src) throws IOException {\n        // for directories, recurse one level to get its files, else skip it\n        if (src.stat.isDirectory()) {\n            if (getDepth() == 0) {\n                recursePath(src);\n            }\n            // skip subdirs\n        } else {\n            srcs.add(src);\n        }\n    }\n}\n}\n\nhadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/CopyCommands.java (After)\nclass CopyCommands {\n/**\n * merge multiple files together\n */\npublic static class Merge extends FsCommand {\n\n    public static final String NAME = \"getmerge\";\n\n    public static final String USAGE = \"[-nl] [-skip-empty-file] \" + \"<src> <localdst>\";\n\n    public static final String DESCRIPTION = \"Get all the files in the directories that \" + \"match the source file pattern and merge and sort them to only \" + \"one file on local fs. <src> is kept.\\n\" + \"-nl: Add a newline character at the end of each file.\\n\" + \"-skip-empty-file: Do not add new line character for empty file.\";\n\n    protected PathData dst = null;\n\n    protected String delimiter = null;\n\n    private boolean skipEmptyFileDelimiter;\n\n    protected List<PathData> srcs = null;\n\n    @Override\n    protected void processOptions(LinkedList<String> args) throws IOException {\n        try {\n            CommandFormat cf = new CommandFormat(2, Integer.MAX_VALUE, \"nl\", \"skip-empty-file\");\n            cf.parse(args);\n            delimiter = cf.getOpt(\"nl\") ? \"\\n\" : null;\n            skipEmptyFileDelimiter = cf.getOpt(\"skip-empty-file\");\n            dst = new PathData(new URI(args.removeLast()), getConf());\n            if (dst.exists && dst.stat.isDirectory()) {\n                throw new PathIsDirectoryException(dst.toString());\n            }\n            srcs = new LinkedList<PathData>();\n        } catch (URISyntaxException e) {\n            throw new IOException(\"unexpected URISyntaxException\", e);\n        }\n    }\n\n    @Override\n    protected void processArguments(LinkedList<PathData> items) throws IOException {\n        super.processArguments(items);\n        if (exitCode != 0) {\n            // check for error collecting paths\n            return;\n        }\n        FSDataOutputStream out = dst.fs.create(dst.path);\n        try {\n            for (PathData src : srcs) {\n                if (src.stat.getLen() != 0) {\n                    try (FSDataInputStream in = src.fs.open(src.path)) {\n                        IOUtils.copyBytes(in, out, getConf(), false);\n                        writeDelimiter(out);\n                    }\n                } else if (!skipEmptyFileDelimiter) {\n                    writeDelimiter(out);\n                }\n            }\n        } finally {\n            out.close();\n        }\n    }\n\n    private void writeDelimiter(FSDataOutputStream out) throws IOException {\n        if (delimiter != null) {\n            out.write(delimiter.getBytes(\"UTF-8\"));\n        }\n    }\n\n    @Override\n    protected void processNonexistentPath(PathData item) throws IOException {\n        // flag that a path is bad\n        exitCode = 1;\n        super.processNonexistentPath(item);\n    }\n\n    // this command is handled a bit differently than others.  the paths\n    // are batched up instead of actually being processed.  this avoids\n    // unnecessarily streaming into the merge file and then encountering\n    // a path error that should abort the merge\n    @Override\n    protected void processPath(PathData src) throws IOException {\n        // for directories, recurse one level to get its files, else skip it\n        if (src.stat.isDirectory()) {\n            if (getDepth() == 0) {\n                recursePath(src);\n            }\n            // skip subdirs\n        } else {\n            srcs.add(src);\n        }\n    }\n}\n}\n",
        "high_level_context": "Ticket ID: HADOOP-12657\nIssue Summary: Add a option to skip newline on empty files with getMerge -nl\nIssue Type: New Feature\nPriority: Minor\n\nDescription:\nHello everyone,\n\nI recently was in the need of using the new line option -nl with getMerge because the files I needed to merge simply didn't had one. I was merging all the files from one directory and unfortunately this directory also included empty files, which effectively led to multiple newlines append after some files. I needed to remove them manually afterwards.\n\nIn this situation it is maybe good to have another argument that allows skipping empty files.\nThing one could try to implement this feature:\n\nThe call for IOUtils.copyBytes(in, out, getConf(), false); doesn't\nreturn the number of bytes copied which would be convenient as one could\nskip append the new line when 0 bytes where copied or one would check the file size before.\n\nI posted this Idea on the mailing list http://mail-archives.apache.org/mod_mbox/hadoop-user/201507.mbox/%3C55B25140.3060005%40trivago.com%3E but I didn't really get many responses, so I thought I my try this way.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n",
        "original_commit_message": "HADOOP-12657. Add a option to skip newline on empty files with getMerge -nl. Contributed by Kanaka Kumar Avvaru.\n\n",
        "commit_type": "feat",
        "commit_subject": "add option to skip newlines for empty files in getmerge command",
        "commit_body": "Added a new `-skip-empty-file` option to the `getmerge` command in CopyCommands. This prevents adding newline characters when merging directories that contain empty files, addressing the issue described in HADOOP-12657. Updated the command description, usage, and logic to support the new flag."
    },
    {
        "diff": "diff --git a/activemq-client/src/main/java/org/apache/activemq/openwire/v10/BaseDataStreamMarshaller.java b/activemq-client/src/main/java/org/apache/activemq/openwire/v10/BaseDataStreamMarshaller.java\nindex 091743ebd..a570d3d17 100644\n--- a/activemq-client/src/main/java/org/apache/activemq/openwire/v10/BaseDataStreamMarshaller.java\n+++ b/activemq-client/src/main/java/org/apache/activemq/openwire/v10/BaseDataStreamMarshaller.java\n@@ -29,6 +29,7 @@ import org.apache.activemq.util.ByteSequence;\n public abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {\n \n     public static final Constructor STACK_TRACE_ELEMENT_CONSTRUCTOR;\n+    private static final int MAX_EXCEPTION_MESSAGE_SIZE = 1024;\n \n     static {\n         Constructor constructor = null;\n@@ -243,7 +244,7 @@ public abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {\n             int rc = 0;\n             bs.writeBoolean(true);\n             rc += tightMarshalString1(o.getClass().getName(), bs);\n-            rc += tightMarshalString1(o.getMessage(), bs);\n+            rc += tightMarshalString1(cutMessageIfNeeded(o.getMessage()), bs);\n             if (wireFormat.isStackTraceEnabled()) {\n                 rc += 2;\n                 StackTraceElement[] stackTrace = o.getStackTrace();\n@@ -264,7 +265,7 @@ public abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {\n                                           BooleanStream bs) throws IOException {\n         if (bs.readBoolean()) {\n             tightMarshalString2(o.getClass().getName(), dataOut, bs);\n-            tightMarshalString2(o.getMessage(), dataOut, bs);\n+            tightMarshalString2(cutMessageIfNeeded(o.getMessage()), dataOut, bs);\n             if (wireFormat.isStackTraceEnabled()) {\n                 StackTraceElement[] stackTrace = o.getStackTrace();\n                 dataOut.writeShort(stackTrace.length);\n@@ -550,7 +551,7 @@ public abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {\n         dataOut.writeBoolean(o != null);\n         if (o != null) {\n             looseMarshalString(o.getClass().getName(), dataOut);\n-            looseMarshalString(o.getMessage(), dataOut);\n+            looseMarshalString(cutMessageIfNeeded(o.getMessage()), dataOut);\n             if (wireFormat.isStackTraceEnabled()) {\n                 StackTraceElement[] stackTrace = o.getStackTrace();\n                 dataOut.writeShort(stackTrace.length);\n@@ -641,4 +642,10 @@ public abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {\n         }\n         return rc;\n     }\n+    \n+    protected String cutMessageIfNeeded(final String message) {\n+        return (message.length() > MAX_EXCEPTION_MESSAGE_SIZE)?\n+            message.substring(0, MAX_EXCEPTION_MESSAGE_SIZE - 3) + \"...\" : message;\n+            \n+    }\n }\n",
        "source_code": "activemq-client/src/main/java/org/apache/activemq/openwire/v10/BaseDataStreamMarshaller.java (Before)\npublic  abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {\npublic static final Constructor STACK_TRACE_ELEMENT_CONSTRUCTOR;\nstatic {\n    Constructor constructor = null;\n    try {\n        constructor = StackTraceElement.class.getConstructor(new Class[] { String.class, String.class, String.class, int.class });\n    } catch (Throwable e) {\n    }\n    STACK_TRACE_ELEMENT_CONSTRUCTOR = constructor;\n}\nprotected int tightMarshalThrowable1(OpenWireFormat wireFormat, Throwable o, BooleanStream bs) throws IOException {\n    if (o == null) {\n        bs.writeBoolean(false);\n        return 0;\n    } else {\n        int rc = 0;\n        bs.writeBoolean(true);\n        rc += tightMarshalString1(o.getClass().getName(), bs);\n        rc += tightMarshalString1(o.getMessage(), bs);\n        if (wireFormat.isStackTraceEnabled()) {\n            rc += 2;\n            StackTraceElement[] stackTrace = o.getStackTrace();\n            for (int i = 0; i < stackTrace.length; i++) {\n                StackTraceElement element = stackTrace[i];\n                rc += tightMarshalString1(element.getClassName(), bs);\n                rc += tightMarshalString1(element.getMethodName(), bs);\n                rc += tightMarshalString1(element.getFileName(), bs);\n                rc += 4;\n            }\n            rc += tightMarshalThrowable1(wireFormat, o.getCause(), bs);\n        }\n        return rc;\n    }\n}\nprotected void tightMarshalThrowable2(OpenWireFormat wireFormat, Throwable o, DataOutput dataOut, BooleanStream bs) throws IOException {\n    if (bs.readBoolean()) {\n        tightMarshalString2(o.getClass().getName(), dataOut, bs);\n        tightMarshalString2(o.getMessage(), dataOut, bs);\n        if (wireFormat.isStackTraceEnabled()) {\n            StackTraceElement[] stackTrace = o.getStackTrace();\n            dataOut.writeShort(stackTrace.length);\n            for (int i = 0; i < stackTrace.length; i++) {\n                StackTraceElement element = stackTrace[i];\n                tightMarshalString2(element.getClassName(), dataOut, bs);\n                tightMarshalString2(element.getMethodName(), dataOut, bs);\n                tightMarshalString2(element.getFileName(), dataOut, bs);\n                dataOut.writeInt(element.getLineNumber());\n            }\n            tightMarshalThrowable2(wireFormat, o.getCause(), dataOut, bs);\n        }\n    }\n}\nprotected void looseMarshalThrowable(OpenWireFormat wireFormat, Throwable o, DataOutput dataOut) throws IOException {\n    dataOut.writeBoolean(o != null);\n    if (o != null) {\n        looseMarshalString(o.getClass().getName(), dataOut);\n        looseMarshalString(o.getMessage(), dataOut);\n        if (wireFormat.isStackTraceEnabled()) {\n            StackTraceElement[] stackTrace = o.getStackTrace();\n            dataOut.writeShort(stackTrace.length);\n            for (int i = 0; i < stackTrace.length; i++) {\n                StackTraceElement element = stackTrace[i];\n                looseMarshalString(element.getClassName(), dataOut);\n                looseMarshalString(element.getMethodName(), dataOut);\n                looseMarshalString(element.getFileName(), dataOut);\n                dataOut.writeInt(element.getLineNumber());\n            }\n            looseMarshalThrowable(wireFormat, o.getCause(), dataOut);\n        }\n    }\n}\nprotected ByteSequence looseUnmarshalByteSequence(DataInput dataIn) throws IOException {\n    ByteSequence rc = null;\n    if (dataIn.readBoolean()) {\n        int size = dataIn.readInt();\n        byte[] t = new byte[size];\n        dataIn.readFully(t);\n        rc = new ByteSequence(t, 0, size);\n    }\n    return rc;\n}\n}\n\nactivemq-client/src/main/java/org/apache/activemq/openwire/v10/BaseDataStreamMarshaller.java (After)\npublic  abstract class BaseDataStreamMarshaller implements DataStreamMarshaller {\npublic static final Constructor STACK_TRACE_ELEMENT_CONSTRUCTOR;\nprivate static final int MAX_EXCEPTION_MESSAGE_SIZE = 1024;\nstatic {\n    Constructor constructor = null;\n    try {\n        constructor = StackTraceElement.class.getConstructor(new Class[] { String.class, String.class, String.class, int.class });\n    } catch (Throwable e) {\n    }\n    STACK_TRACE_ELEMENT_CONSTRUCTOR = constructor;\n}\nprotected int tightMarshalThrowable1(OpenWireFormat wireFormat, Throwable o, BooleanStream bs) throws IOException {\n    if (o == null) {\n        bs.writeBoolean(false);\n        return 0;\n    } else {\n        int rc = 0;\n        bs.writeBoolean(true);\n        rc += tightMarshalString1(o.getClass().getName(), bs);\n        rc += tightMarshalString1(cutMessageIfNeeded(o.getMessage()), bs);\n        if (wireFormat.isStackTraceEnabled()) {\n            rc += 2;\n            StackTraceElement[] stackTrace = o.getStackTrace();\n            for (int i = 0; i < stackTrace.length; i++) {\n                StackTraceElement element = stackTrace[i];\n                rc += tightMarshalString1(element.getClassName(), bs);\n                rc += tightMarshalString1(element.getMethodName(), bs);\n                rc += tightMarshalString1(element.getFileName(), bs);\n                rc += 4;\n            }\n            rc += tightMarshalThrowable1(wireFormat, o.getCause(), bs);\n        }\n        return rc;\n    }\n}\nprotected void tightMarshalThrowable2(OpenWireFormat wireFormat, Throwable o, DataOutput dataOut, BooleanStream bs) throws IOException {\n    if (bs.readBoolean()) {\n        tightMarshalString2(o.getClass().getName(), dataOut, bs);\n        tightMarshalString2(cutMessageIfNeeded(o.getMessage()), dataOut, bs);\n        if (wireFormat.isStackTraceEnabled()) {\n            StackTraceElement[] stackTrace = o.getStackTrace();\n            dataOut.writeShort(stackTrace.length);\n            for (int i = 0; i < stackTrace.length; i++) {\n                StackTraceElement element = stackTrace[i];\n                tightMarshalString2(element.getClassName(), dataOut, bs);\n                tightMarshalString2(element.getMethodName(), dataOut, bs);\n                tightMarshalString2(element.getFileName(), dataOut, bs);\n                dataOut.writeInt(element.getLineNumber());\n            }\n            tightMarshalThrowable2(wireFormat, o.getCause(), dataOut, bs);\n        }\n    }\n}\nprotected void looseMarshalThrowable(OpenWireFormat wireFormat, Throwable o, DataOutput dataOut) throws IOException {\n    dataOut.writeBoolean(o != null);\n    if (o != null) {\n        looseMarshalString(o.getClass().getName(), dataOut);\n        looseMarshalString(cutMessageIfNeeded(o.getMessage()), dataOut);\n        if (wireFormat.isStackTraceEnabled()) {\n            StackTraceElement[] stackTrace = o.getStackTrace();\n            dataOut.writeShort(stackTrace.length);\n            for (int i = 0; i < stackTrace.length; i++) {\n                StackTraceElement element = stackTrace[i];\n                looseMarshalString(element.getClassName(), dataOut);\n                looseMarshalString(element.getMethodName(), dataOut);\n                looseMarshalString(element.getFileName(), dataOut);\n                dataOut.writeInt(element.getLineNumber());\n            }\n            looseMarshalThrowable(wireFormat, o.getCause(), dataOut);\n        }\n    }\n}\nprotected ByteSequence looseUnmarshalByteSequence(DataInput dataIn) throws IOException {\n    ByteSequence rc = null;\n    if (dataIn.readBoolean()) {\n        int size = dataIn.readInt();\n        byte[] t = new byte[size];\n        dataIn.readFully(t);\n        rc = new ByteSequence(t, 0, size);\n    }\n    return rc;\n}\nprotected String cutMessageIfNeeded(final String message) {\n    return (message.length() > MAX_EXCEPTION_MESSAGE_SIZE) ? message.substring(0, MAX_EXCEPTION_MESSAGE_SIZE - 3) + \"...\" : message;\n}\n}\n",
        "high_level_context": "Ticket ID: AMQ-6894\nIssue Summary: Excessive number of connections by failover transport with priorityBackup\nIssue Type: Bug\nPriority: Major\n\nDescription:\nMy clients connect to AMQ with this connection string:\r\n\r\n(tcp://amq1:61616,tcp://amq2:61616)?randomize=false&priorityBackup=true\r\n\r\n\u00a0It works - for some time. But sooner or later my AMQ server becomes unresponsive because the host it runs on runs out of resources (threads).\r\n\r\nSuddenly AMQ Server log explodes with the messages like:\r\n\r\n{code}\r\n2018-01-26 09:26:16,909 | WARN\u00a0 | Failed to register MBean org.apache.activemq :type=Broker,brokerName=activemq-vm-primary,connector=clientConnectors,connect\r\n\r\norName=default,connectionViewType=clientId,connectionName=ID_ca8f70e115d0-3708\r\n\r\n7-1516883370639-0_22 | org.apache.activemq.broker.jmx.ManagedTransportConnecti\r\n\r\non | ActiveMQ Transport: tcp:///172.10.7.56:55548@61616\r\n\r\n2018-01-26 09:26:21,375 | WARN\u00a0 | Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. Ignored ack: MessageAck \\{commandId = 157, responseRequired = false, ackType = 2, consumerId = ID:ca8f70e115d0-37087-1516883370639-1:22:10:1, firstMessageId = ID:a95345a9c0df-33771-1516883685728-1:17:5:1:23, lastMessageId = ID:a95345a9c0df-33771-1516883685728-1:17:5:1:23, destination = queue://MY_QUEUE_OUT, transactionId = null, messageCount = 1, poisonCause = null} | org.apache.activemq.broker.region.PrefetchSubscription | ActiveMQ Transport: tcp:///172.16.6.56:55464@61616\r\n\r\n2018-01-26 09:26:39,211 | WARN\u00a0 | Transport Connection to: tcp://172.10.6.56:55860 failed: java.net.SocketException: Connection reset | org.apache.activemq.broker.TransportConnection.Transport | ActiveMQ InactivityMonitor Worker\r\n\r\n2018-01-26 09:26:47,175 | WARN\u00a0 | Transport Connection to: tcp://172.10.6.56:57012 failed: java.net.SocketException: Broken pipe (Write failed) | org.apache.activemq.broker.TransportConnection.Transport | ActiveMQ InactivityMonitor Worker\r\n{code}\r\n\r\nAfter short period of time AMQ server comes out of resources with \"java.lang.OutOfMemoryError: unable to create new native thread\" error. The AMQ service process in this case has a huge number of threads (some thousands)\r\n\r\n\u00a0\r\n\r\nThe client side log contains a lot of reconnection attempts messages like:\r\n\r\n{code}\r\n2018-01-26 00:10:31,387 WARN\u00a0\u00a0\u00a0 [\\{{bundle.name,org.apache.activemq.activemq-osgi}{bundle.version,5.14.1}\\{bundle.id,181}}]\u00a0\u00a0\u00a0\u00a0 [null]\u00a0 org.apache.activemq.transport.failover.FailoverTransport\u00a0 \u00a0\u00a0\u00a0\u00a0Failed to connect to [tcp://activemq-vm-primary:61616, tcp://activemq-vm-secondary:61616] after: 810 attempt(s) continuing to retry.\r\n{code}\r\n\r\nIt seems that client creates a huge number of connections by failover retry and after some time kills the server.\r\n\r\nIssue looks very similar to described in https://issues.apache.org/jira/browse/AMQ-6603, however server isn't configured with access control settings.\r\n\r\nI found the description of similar problem into [http://activemq.2283324.n4.nabble.com/ActiveMQ-5-2-OutOfMemoryError-unable-to-create-new-native-thread-td2366585.html],\u00a0 but without concrete suggestion.\r\n\r\n\u00a0\r\n\r\nPart of server log is attached\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n",
        "original_commit_message": "AMQ-6894: limit poison exception message to 1024\n\n",
        "commit_type": "fix",
        "commit_subject": "limit exception message size to prevent resource exhaustion",
        "commit_body": "Introduced a `MAX_EXCEPTION_MESSAGE_SIZE` constant (1024 characters) and added logic to truncate overly long exception messages in `BaseDataStreamMarshaller`. This prevents excessive memory and resource usage due to unbounded exception message sizes, addressing the issue in AMQ-6894."
    },
    {
        "diff": "diff --git a/src/java/org/apache/cassandra/hints/HintsDispatchTrigger.java b/src/java/org/apache/cassandra/hints/HintsDispatchTrigger.java\nindex ca38c0c319..fbaeaebcb8 100644\n--- a/src/java/org/apache/cassandra/hints/HintsDispatchTrigger.java\n+++ b/src/java/org/apache/cassandra/hints/HintsDispatchTrigger.java\n@@ -19,20 +19,13 @@ package org.apache.cassandra.hints;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import org.apache.cassandra.gms.ApplicationState;\n-import org.apache.cassandra.gms.Gossiper;\n-import org.apache.cassandra.schema.Schema;\n-\n-import static org.apache.cassandra.utils.FBUtilities.getBroadcastAddressAndPort;\n-\n /**\n  * A simple dispatch trigger that's being run every 10 seconds.\n  *\n  * Goes through all hint stores and schedules for dispatch all the hints for hosts that are:\n  * 1. Not currently scheduled for dispatch, and\n  * 2. Either have some hint files, or an active hint writer, and\n- * 3. Are live, and\n- * 4. Have matching schema versions\n+ * 3. Are live\n  *\n  * What does triggering a hints store for dispatch mean?\n  * - If there are existing hint files, it means submitting them for dispatch;\n@@ -65,7 +58,6 @@ final class HintsDispatchTrigger implements Runnable\n                .filter(store -> !isScheduled(store))\n                .filter(HintsStore::isLive)\n                .filter(store -> store.isWriting() || store.hasFiles())\n-               .filter(store -> Schema.instance.isSameVersion(Gossiper.instance.getSchemaVersion(store.address())))\n                .forEach(this::schedule);\n     }\n \n",
        "source_code": "src/java/org/apache/cassandra/hints/HintsDispatchTrigger.java (Before)\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.cassandra.gms.ApplicationState;\nimport org.apache.cassandra.gms.Gossiper;\nimport org.apache.cassandra.schema.Schema;\nimport static org.apache.cassandra.utils.FBUtilities.getBroadcastAddressAndPort;\nfinal class HintsDispatchTrigger implements Runnable {\npublic void run() {\n    if (isPaused.get())\n        return;\n    catalog.stores().filter(store -> !isScheduled(store)).filter(HintsStore::isLive).filter(store -> store.isWriting() || store.hasFiles()).filter(store -> Schema.instance.isSameVersion(Gossiper.instance.getSchemaVersion(store.address()))).forEach(this::schedule);\n}\n}\n\nsrc/java/org/apache/cassandra/hints/HintsDispatchTrigger.java (After)\nimport java.util.concurrent.atomic.AtomicBoolean;\nfinal class HintsDispatchTrigger implements Runnable {\npublic void run() {\n    if (isPaused.get())\n        return;\n    catalog.stores().filter(store -> !isScheduled(store)).filter(HintsStore::isLive).filter(store -> store.isWriting() || store.hasFiles()).forEach(this::schedule);\n}\n}\n",
        "high_level_context": "Ticket ID: CASSANDRA-20188\nIssue Summary: Allow hint delivery during schema mismatch\nIssue Type: Bug\nPriority: Normal\n\nDescription:\nIn CASSANDRA-2083 we made hints require schema agreement to avoid a flood of errors in case the table the hints were destined for did not yet exist.  This, however, has other undesirable effects, such as making keeping upgrades in a mixed mode over a longer period of time less tenable.  We should still try to deliver hints and back off if the destination table doesn't exist.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n",
        "original_commit_message": "Allow hint delivery during schema mismatch\n\nPatch by brandonwilliams; reviewed by smiklosovic for CASSANDRA-20188\n\n",
        "commit_type": "fix",
        "commit_subject": "allow hint delivery during schema mismatch",
        "commit_body": "Removed schema version checks in `HintsDispatchTrigger` to enable hint delivery even during schema mismatches. This change ensures smoother operations in mixed-mode upgrades by allowing hint dispatch while backing off if the destination table does not exist, addressing issue CASSANDRA-20188."
    }
]