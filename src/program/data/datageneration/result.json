[
    {
        "diff": "diff --git a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\nindex e6e2a4cd8..1c6fcda23 100644\n--- a/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n+++ b/src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt\n@@ -10,6 +10,7 @@ import org.springframework.boot.web.servlet.MultipartConfigFactory\n import org.springframework.context.annotation.Bean\n import org.springframework.context.annotation.Configuration\n import org.springframework.http.CacheControl\n+import org.springframework.scheduling.annotation.EnableScheduling\n import org.springframework.util.unit.DataSize\n import org.springframework.web.client.RestTemplate\n import org.springframework.web.servlet.config.annotation.CorsRegistry\n@@ -21,6 +22,7 @@ import java.util.concurrent.TimeUnit\n import javax.servlet.MultipartConfigElement\n \n @Configuration\n+@EnableScheduling\n class WebConfiguration(\n   private val tolgeeProperties: TolgeeProperties\n ) : WebMvcConfigurer {\ndiff --git a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\nindex fa5c1f80c..a86be1125 100644\n--- a/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n+++ b/src/main/kotlin/io/tolgee/service/ImageUploadService.kt\n@@ -66,7 +66,7 @@ class ImageUploadService(\n   @Transactional\n   @Scheduled(fixedRate = 60000)\n   fun cleanOldImages() {\n-    logger.info(\"Clearing images\")\n+    logger.debug(\"Clearing images\")\n     val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n     uploadedImageRepository.findAllOlder(Date.from(time)).let { images ->\n       images.forEach { delete(it) }\n",
        "source_code": "src/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (Before)\n@Configuration class WebConfiguration(private val tolgeeProperties: TolgeeProperties) : WebMvcConfigurer{\n\n}\nsrc/main/kotlin/io/tolgee/configuration/WebConfiguration.kt (After)\n@Configuration @EnableScheduling class WebConfiguration(private val tolgeeProperties: TolgeeProperties) : WebMvcConfigurer{\n\n}\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (Before)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.info(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}\nsrc/main/kotlin/io/tolgee/service/ImageUploadService.kt (After)\n@Service class ImageUploadService(val uploadedImageRepository: UploadedImageRepository, val fileStorageService: FileStorageService, val dateProvider: CurrentDateProvider) : {\n    @Transactional @Scheduled(fixedRate = 60000) fun cleanOldImages() {\n        logger.debug(\"Clearing images\")\n        val time = dateProvider.getDate().toInstant().minus(2, ChronoUnit.HOURS)\n        uploadedImageRepository.findAllOlder(Date.from(time)).let { images -> images.forEach { delete(it) } }\n    }\n}",
        "high_level_context": "**USER-TOLGEE-7: User Authentication and Authorization**  \nThe application shall provide a robust user authentication and authorization mechanism to ensure secure access to the platform. \n\n1. **User Registration**  \n   Users must be able to register for an account by providing their email address and creating a password. An email verification process should be implemented to confirm the user's identity before account activation.\n\n2. **Login Process**  \n   The system must allow users to log in using their registered email and password. If the user forgets their password, they should be able to initiate a password reset process via email.\n\n3. **Role-Based Access Control**  \n   Different roles must be defined within the application (e.g., Admin, User, Guest). Each role should have specific permissions associated with it to control access to various features and functionalities.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n**USER-TOLGEE-18: Image Upload and Management**  \nThe application shall allow users to upload and manage images within the platform, facilitating easy access and organization.\n\n1. **Image Upload Feature**  \n   Users must be able to upload images through a user-friendly interface. The system should support multiple image formats and provide feedback on the upload status.\n\n2. **Image Storage and Retrieval**  \n   Uploaded images must be stored securely and should be retrievable by users at any time. The application should implement efficient storage management to accommodate large volumes of images.\n\n3. **Image Deletion**  \n   Users should have the ability to delete their uploaded images. The system must provide confirmation prompts to prevent accidental deletions.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n**USER-TOLGEE-20: Scheduling Tasks**  \nThe application shall support background task scheduling to automate certain processes, thereby improving efficiency and user experience.\n\n1. **Periodic Cleanup Tasks**  \n   The system must automatically perform periodic cleanup of old data, such as images that have not been accessed for a specified duration. This will help in managing storage space effectively.\n\n2. **User Notifications**  \n   Scheduled tasks should also include sending notifications to users for various events (e.g., reminders, updates). Users must be able to configure their notification preferences.\n\n3. **Task Management Interface**  \n   An interface should be provided for system administrators to manage and monitor scheduled tasks. This includes the ability to add, modify, or remove tasks as necessary.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n",
        "commit_message": "fix: Uploaded images are not deleted periodically TG-353",
        "new_commit_message": "feat: enable scheduling and improve logging for image cleanup\n\nEnabled task scheduling in WebConfiguration using @EnableScheduling annotation to support background tasks as per USER-TOLGEE-20 requirements. Updated logging in ImageUploadService from info to debug level for periodic image cleanup to enhance log clarity."
    },
    {
        "diff": "diff --git a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\nindex 348bea7e5..9dc65f1b3 100644\n--- a/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n+++ b/app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt\n@@ -56,18 +56,18 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n         this.viewModel.outputs.showConfirmLogoutPrompt()\n                 .compose(bindToLifecycle())\n                 .observeOn(AndroidSchedulers.mainThread())\n-                .subscribe({ show ->\n+                .subscribe { show ->\n                     if (show) {\n                         lazyLogoutConfirmationDialog().show()\n                     } else {\n                         lazyLogoutConfirmationDialog().dismiss()\n                     }\n-                })\n+                }\n \n         this.viewModel.outputs.userNameTextViewText()\n                 .compose(bindToLifecycle())\n                 .compose(Transformers.observeForUI())\n-                .subscribe({ name_text_view.text = it })\n+                .subscribe { name_text_view.text = it }\n \n         account_row.setOnClickListener {\n             startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java))\n@@ -93,10 +93,6 @@ class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>() {\n             startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java))\n         }\n \n-        privacy_row.setOnClickListener {\n-            startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java))\n-        }\n-\n         rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n     }\n \n",
        "source_code": "app/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (Before)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe({ show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } })\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe({ name_text_view.text = it })\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        privacy_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, PrivacyActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}\napp/src/main/java/com/kickstarter/ui/activities/SettingsActivity.kt (After)\n@RequiresActivityViewModel(SettingsViewModel.ViewModel::class) class SettingsActivity : BaseActivity<SettingsViewModel.ViewModel>(){\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.settings_layout)\n        if (BuildConfig.DEBUG) {\n            edit_profile_row.visibility = View.VISIBLE\n        }\n        this.build = environment().build()\n        this.currentUser = environment().currentUser()\n        this.ksString = environment().ksString()\n        this.logout = environment().logout()\n        version_name_text_view.text = ksString.format(getString(R.string.profile_settings_version_number), \"version_number\", this.build.versionName())\n        this.viewModel.outputs.avatarImageViewUrl().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { url -> Picasso.with(this).load(url).transform(CircleTransformation()).into(profile_picture_image_view) }\n        this.viewModel.outputs.logout().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { logout() }\n        this.viewModel.outputs.showConfirmLogoutPrompt().compose(bindToLifecycle()).observeOn(AndroidSchedulers.mainThread()).subscribe { show -> if (show) {\n            lazyLogoutConfirmationDialog().show()\n        } else {\n            lazyLogoutConfirmationDialog().dismiss()\n        } }\n        this.viewModel.outputs.userNameTextViewText().compose(bindToLifecycle()).compose(Transformers.observeForUI()).subscribe { name_text_view.text = it }\n        account_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, AccountActivity::class.java)) }\n        edit_profile_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, EditProfileActivity::class.java)) }\n        help_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, HelpSettingsActivity::class.java)) }\n        log_out_row.setOnClickListener { this.viewModel.inputs.logoutClicked() }\n        newsletters_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NewsletterActivity::class.java)) }\n        notification_row.setOnClickListener { startActivityWithSlideUpTransition(Intent(this, NotificationsActivity::class.java)) }\n        rate_us_row.setOnClickListener { ViewUtils.openStoreRating(this, this.packageName) }\n    }\n}",
        "high_level_context": "\n### REQ-KICKSTARTER-14: User Profile Management\n#### 14.1 Profile Picture Display\nUsers should be able to see their profile picture on the settings screen. The application will retrieve the user\u2019s avatar image URL from the server and display it in the designated profile picture area. If the user has not set a picture, a default image should be shown instead.\n\n#### 14.2 User Name Display\nThe application should display the user's name prominently on the settings screen. This name should be fetched from the user's profile data when they log in to the application and should update dynamically if the user changes their profile information.\n\n#### 14.3 Logout Functionality\nUsers need a clear and accessible option to log out of their account. Upon clicking the logout button, the application will prompt the user to confirm their decision before logging them out to prevent accidental logouts.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n### REQ-KICKSTARTER-19: Account Management\n#### 19.1 Accessing Account Settings\nUsers should have an option to access their account settings directly from the settings menu. This should allow them to view and edit their account information, including their email address and password.\n\n#### 19.2 Editing Profile\nThe application should provide a feature for users to edit their profile information. When users select the edit profile option, they should be directed to a new screen where they can update their personal details, including their name and profile picture.\n\n#### 19.3 Newsletter Preferences\nUsers should have the ability to manage their newsletter preferences from the settings screen. This includes opting-in or opting-out of newsletters and managing other communication preferences.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n### REQ-KICKSTARTER-10: User Assistance\n#### 10.1 Help and Support Access\nThe application should include a help section accessible from the settings menu. Users should be able to find FAQs and contact support directly from this section for any assistance they may require.\n\n#### 10.2 Rate Us Feature\nUsers should be encouraged to rate the application. A \"Rate Us\" button should be available in the settings menu, allowing users to quickly access the app store rating page.\n\n#### 10.3 Privacy Policy Access (**Updated**)\nUsers should access the application's privacy policy from the main menu instead of the settings menu. This change ensures greater visibility and accessibility, emphasizing our commitment to transparency regarding user data and privacy practices. A dedicated option should be provided that opens the privacy policy in a web view or an external browser.\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n",
        "commit_message": "Removing privacy from root Settings menu (#456)",
        "new_commit_message": "fix: remove privacy from root Settings menu\n\nRemoved the privacy row from the root Settings menu as part of updating the Privacy Policy Access feature (REQ-KICKSTARTER-10.3). Other changes are for refactoring purposes."
    },
    {
        "diff": "diff --git a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\nindex 470821ebe..03de4e4bb 100644\n--- a/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n+++ b/app/src/main/java/com/breadwallet/repository/MessagesRepository.kt\n@@ -28,6 +28,7 @@ import android.content.Context\n import android.util.Log\n import com.breadwallet.model.InAppMessage\n import com.breadwallet.tools.manager.BRSharedPrefs\n+import com.breadwallet.tools.util.EventUtils\n import com.platform.network.InAppMessagesClient\n \n /**\n@@ -56,6 +57,8 @@ object MessagesRepository {\n         // for notifications.\n         val inAppMessage = inAppMessages[0]\n         Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\n         return inAppMessage\n     }\n \ndiff --git a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\nindex 66f470850..9c5294ff5 100644\n--- a/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n+++ b/app/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt\n@@ -49,6 +49,8 @@ class InAppNotificationActivity : BRActivity() {\n         private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n \n         fun start(context: Context, notification: InAppMessage) {\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n             val intent = Intent(context, InAppNotificationActivity::class.java).apply {\n                 putExtra(EXT_NOTIFICATION, notification)\n             }\n@@ -70,6 +72,10 @@ class InAppNotificationActivity : BRActivity() {\n         notification_btn.setOnClickListener {\n             viewModel.markAsRead()\n             val actionUrl = viewModel.notification.actionButtonUrl\n+            val notificationId = viewModel.notification.id\n+            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON,\n+                    mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId,\n+                            EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n             if (!actionUrl.isNullOrEmpty()) {\n                 if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                     AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n@@ -89,6 +95,8 @@ class InAppNotificationActivity : BRActivity() {\n     override fun onBackPressed() {\n         super.onBackPressed()\n         viewModel.markAsRead()\n+        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED,\n+                mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n     }\n \n }\n\\ No newline at end of file\n",
        "source_code": "app/src/main/java/com/breadwallet/repository/MessagesRepository.kt (Before)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/repository/MessagesRepository.kt (After)\n object MessagesRepository : {\n    fun getInAppNotification(context: Context): InAppMessage? {\n        Log.d(TAG, \"getInAppNotification: Looking for new in app notifications\")\n        val readMessages = BRSharedPrefs.getReadInAppNotificationIds(context)\n        val inAppMessages = InAppMessagesClient.fetchMessages(context, InAppMessage.Type.IN_APP_NOTIFICATION).filterNot { readMessages.contains(it.messageId) }\n        if (inAppMessages.isEmpty()) {\n            Log.d(TAG, \"getInAppNotification: There are no new notifications\")\n            return null\n        }\n        val inAppMessage = inAppMessages[0]\n        Log.d(TAG, \"getInAppNotification: ${inAppMessage.title}\")\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_RECEIVED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to inAppMessage.id))\n        return inAppMessage\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (Before)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n    }\n}\napp/src/main/java/com/breadwallet/ui/notification/InAppNotificationActivity.kt (After)\n class InAppNotificationActivity : BRActivity(){\n    companion object {\n        private val TAG: String = InAppNotificationActivity::class.java.simpleName\n\n        private const val EXT_NOTIFICATION = \"com.breadwallet.ui.notification.EXT_NOTIFICATION\"\n\n        fun start(context: Context, notification: InAppMessage) {\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_APPEARED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notification.id))\n            val intent = Intent(context, InAppNotificationActivity::class.java).apply { putExtra(EXT_NOTIFICATION, notification) }\n            context.startActivity(intent)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_in_app_notification)\n        close_button.setOnClickListener { onBackPressed() }\n        notification_btn.setOnClickListener {\n            viewModel.markAsRead()\n            val actionUrl = viewModel.notification.actionButtonUrl\n            val notificationId = viewModel.notification.id\n            EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_CTA_BUTTON, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to notificationId, EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_CTA_URL to actionUrl))\n            if (!actionUrl.isNullOrEmpty()) {\n                if (AppEntryPointHandler.isDeepLinkPlatformUrl(actionUrl)) {\n                    AppEntryPointHandler.processPlatformDeepLinkingUrl(this, actionUrl)\n                } else {\n                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(actionUrl)))\n                }\n            }\n            finish()\n        }\n        notification_title.text = viewModel.notification.title\n        notification_body.text = viewModel.notification.body\n        notification_btn.text = viewModel.notification.actionButtonText\n        Picasso.get().load(viewModel.notification.imageUrl).into(notification_image)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        viewModel.markAsRead()\n        EventUtils.pushEvent(EventUtils.EVENT_IN_APP_NOTIFICATION_DISMISSED, mapOf(EventUtils.EVENT_ATTRIBUTE_NOTIFICATION_ID to viewModel.notification.id))\n    }\n}",
        "high_level_context": "USERSTORY-InAppNotification-9\n\n### Requirement Overview\nThe application shall provide users with in-app notifications to deliver important updates and messages directly within the app interface.\n\n#### 9.1 Notification Retrieval\nThe system must check for new in-app notifications whenever the user accesses the app. It should filter out notifications that have already been read by the user to ensure that only new and relevant notifications are displayed.\n\n#### 9.2 Notification Display\nOnce a new notification is retrieved, the application will present it to the user through a dedicated notification interface. This interface should include the notification title, body, action button, and an image, if applicable. The user should be able to easily recognize and understand the content of the notification.\n\n#### 9.3 User Interaction\nThe user must be able to interact with the notification. This includes marking the notification as read and following any associated action URL through a provided button. The system should ensure that the notification is logged appropriately for analytics purposes whenever the user interacts with it.\n\n---\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\nUSERSTORY-InAppNotification-10\n\n### Requirement Overview\nThe application must ensure that in-app notifications are presented in a user-friendly manner, enhancing user engagement and interaction with the application.\n\n#### 10.1 Notification Launch\nWhen the user taps on a notification, the application should launch a specific activity designed to display the notification details. This activity must show all relevant information, including the notification content and any actionable items.\n\n#### 10.2 Back Navigation\nUpon returning from the notification interface, the application must mark the notification as read to avoid cluttering the user's notification history. This action should be logged for further analysis on user interaction patterns.\n\n#### 10.3 Event Tracking\nThe system must track various events related to the in-app notifications, such as when a notification is displayed, when it is interacted with, and when it is dismissed. This data will be essential for understanding user behavior and improving future notifications.\n\n---\n\n--- RETRIEVED DOCUMENT SPLIT END ---\n\n",
        "commit_message": "DROID-1355: Add analytics for in-app messages.",
        "new_commit_message": "feat: add event tracking for in-app notifications\n\nImplemented event tracking for in-app notifications to support USERSTORY-InAppNotification-9 and USERSTORY-InAppNotification-10. Events include notification received, displayed, interacted with (CTA button), and dismissed. "
    }
]